<NAV><HEADER><P><B>Table of Contents</B></P></HEADER><OL><LI><A HREF="#section-1">Example of Geneva documentation for a Common Lisp library</A><OL><LI><A HREF="#section-1-1">Pros &amp; Cons of Coo</A><OL><LI><A HREF="#section-1-1-1">Pros</A></LI><LI><A HREF="#section-1-1-2">Cons</A></LI></OL></LI><LI><A HREF="#section-1-2">Handwritten documentation</A></LI><LI><A HREF="#section-1-3">Extending Geneva</A></LI><LI><A HREF="#section-1-4">Autogenerated API</A></LI></OL></LI></OL></NAV><SECTION><HEADER><A NAME="section-1"><H1><SPAN CLASS="geneva-index">1</SPAN> Example of Geneva documentation for a Common Lisp library</H1></A></HEADER><P>This is a small library includes a few functions with docstrings and a documentation for the system and all included packages.</P><P>The purpose is to demonstrate core features of the <A HREF="https://inters.co/geneva/open-geneva.html">Geneva</A> documentation system.</P><P>The repository can be used as a template for new libraries if you've choosen <CODE>Geneva</CODE> for documenting your library.</P><P>Let's review features, provided by <CODE>Geneva</CODE>.</P><SECTION><HEADER><A NAME="section-1-1"><H2><SPAN CLASS="geneva-index">1.1</SPAN> Pros &amp; Cons of Coo</H2></A></HEADER><SECTION><HEADER><A NAME="section-1-1-1"><H3><SPAN CLASS="geneva-index">1.1.1</SPAN> Pros</H3></A></HEADER><UL><LI><CODE>Geneva</CODE> separates phases of the document construction and rendering. Documents can be written in many formats and all you need is a parser which will return the documennt as a nested list structure like:</LI></UL><FIGURE><PRE>((:SECTION ("First section")
  ((:PARAGRAPH ("Foo bar"))
   (:PARAGRAPH ("Blah minor"))))
 (:SECTION ("Second section")
  ((:PARAGRAPH ((:BOLD "Hello World!"))))))</PRE></FIGURE><UL><LI>Docstrings can be written in mk2 format.</LI></UL></SECTION><SECTION><HEADER><A NAME="section-1-1-2"><H3><SPAN CLASS="geneva-index">1.1.2</SPAN> Cons</H3></A></HEADER><UL><LI>There is no a function to build documentation for your system. You have to define it manually or to create a separate library which will find documents, extract docstrings, etc.</LI><LI><CODE>Geneva</CODE> includes <A HREF="https://inters.co/geneva/mk2.html">mk2</A> markup format which is very strange. To use Markdown or reStructured text you'll need to write a separate parser.</LI><LI>There is no cross-reference facility, but probably it <A HREF="https://github.com/eugeneia/geneva/issues/1">could be implemented</A> as part of the <CODE>geneva.cl:api-document</CODE>.</LI><LI><CODE>geneva.cl:api-document</CODE> works with packages and it will be hard to use it for building documentation for a package infrerred ASDF system.</LI><LI>It is impossible to reference documentation sections.</LI><LI>There is no builtin HTML themes.</LI><LI>Types of inner document elements are hardcoded and it is impossible to add new blocks use some hooks to change the way how the document is rendered.</LI><LI>Code blocks don't support highlighting:</LI></UL><FIGURE><PRE>(defun render-content (content level)
  "Render CONTENT as HTML."
  (case (content-type content)
    (:paragraph (render-paragraph content))
    (:listing   (render-listing content))
    (:table     (render-table content))
    (:media     (render-media content))
    (:plaintext (render-plaintext content))
    (:section   (render-section content level))
    (t (error "Invalid content type in CONTENT: ~S."
	      (content-type content)))))</PRE></FIGURE></SECTION></SECTION><SECTION><HEADER><A NAME="section-1-2"><H2><SPAN CLASS="geneva-index">1.2</SPAN> Handwritten documentation</H2></A></HEADER><P>I think the ability to write a large pieces of documentation which aren't bound to a function, class or module is an important feature. This way you can tell the user about some toplevel abstractions and give a bird eye view on the library or system.</P><P>For example, handwritten parts of the documentation can provide some code snippets to demonstrate the ways, how to use the library:</P><FIGURE><PRE>(loop repeat 42
     collect (foo "bar" 100500))</PRE></FIGURE><P>And when you are talking about some function or class, you can reference it. For example, if I'm talking about <CODE>foo</CODE> function, I want to be able to reference it.</P><P>But <CODE>Geneva</CODE> does not support cross referencing. And you have to write links manually: <CODE>[example/app:foo](example/app.html#section-1-1)</CODE> and it will appear in the code as the link <A HREF="example/app.html#section-1-1">example/app:foo</A></P></SECTION><SECTION><HEADER><A NAME="section-1-3"><H2><SPAN CLASS="geneva-index">1.3</SPAN> Extending Geneva</H2></A></HEADER><P><CODE>Geneva</CODE> consists of usual functions and can't be easily hacked around. However, you can do some document processing before the rendering.</P></SECTION><SECTION><HEADER><A NAME="section-1-4"><H2><SPAN CLASS="geneva-index">1.4</SPAN> Autogenerated API</H2></A></HEADER><P><CODE>Geneva</CODE> provides a function <CODE>geneva.cl:api-document</CODE> to create a document for a Lisp package. For example, it is used by this example project to build docs for two subpackages:</P><FIGURE><PRE>(flet ((document-package (package)
           (check-type package keyword)
           (let ((filename (format nil "docs/build/~A.html"
                                   (string-downcase package))))
             (ensure-directories-exist filename)
             (uiop:with-output-file (s filename
                                       :if-exists :supersede)
               (geneva.html:render-html (geneva.cl:api-document package)
                                        :stream s)))))
    (document-package :example/app)
    (document-package :example/utils))</PRE></FIGURE><P>Here is the results:</P><UL><LI><A HREF="example/app.html">example/app</A></LI><LI><A HREF="example/utils.html">example/utils</A></LI></UL><P>For a package infrred ASDF system a function can be written, which will discover all subpackages.</P></SECTION></SECTION>